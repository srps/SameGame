;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;																	;;;
;;;			Procura e Planeamento 2012-2013                 ;;;
;;;			Projecto Same Game	                        ;;;
;;;									;;;
;;;			Grupo 002				        ;;;
;;;			55457 - Sergio Miguel Silva			;;;
;;;			56886 - Marco Andre Ferreira			;;;
;;;									;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package :user)

(eval-when (compile) (declaim (optimize (speed 3) (safety 0) (debug 0))))

(declare (optimize (speed 3) (safety 0) (space 0)
                   (debug 0) (compilation-speed 0)
                   #+lispworks (float 0)
                   #+lispworks (fixnum-safety 0)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;	DEFINICOES  DE CONSTANTES 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(defconstant MAX-TEMPO 250) ;;Tempo limite de tempo para execução



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;	TEMPO
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



;--------------------------------------------------------------------------;
; Função que calcula tempo restante                                        ;
;--------------------------------------------------------------------------;
; ARG1 - tempo inicia                                                      ;
; ARG2 - segundos passados                                                 ;
;--------------------------------------------------------------------------;             
(defun time-to-stop? (tempo-inicio n-segundos)
        (<= (* n-segundos INTERNAL-TIME-UNITS-PER-SECOND) (- (get-start-time) tempo-inicio)))

;--------------------------------------------------------------------------;
; Função que retorna o tempo interno actual                                ;
;--------------------------------------------------------------------------;
; ARG1 - tempo inicia                                                      ;
; ARG2 - segundos passados                                                 ;
;--------------------------------------------------------------------------; 
(defun get-start-time ()
                (get-internal-run-time))




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;	DEFINICOES  e  ESTRUTURAS  DE  DADOS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defvar *max-result* 0)
(defvar tempo-inicio (get-internal-run-time))
(defvar *tamanho-tabuleiro* 0)
(defvar *no-id* 0)

(defstruct peca
  pos                         ; posição da peça (x . y)
  (cor -1 :type fixnum)       ; cor da peça
  (bloco -1 :type fixnum)     ; bloco a que pertence a peça
)

(defstruct bloco
  (cor -1 :type fixnum)       ; cor do bloco
  lista-pecas                 ; lista das peças do bloco
  (id -1 :type fixnum)        ; identificador do bloco
  (x-min 20 :type fixnum)
  (x-max -1 :type fixnum)
  (y-min 20 :type fixnum)
  (y-max -1 :type fixnum)
)

	
(defstruct nos
  (pontuacao 0 :type fixnum) ; Pontuação até ao momento do estado
  (prof 0 :type fixnum)
  (n-pecas 0 :type fixnum)    ; Peças por eliminar
  (n-blocos 0 :type fixnum)   ; Blocos por eliminar         
  tabuleiro
  h-blocos                    ; Hash com os blocos existentes	
  (n-linhas 0 :type fixnum)   ; Numero de linhas com peças
  (n-colunas 0 :type fixnum)  ; Numero de colunas com peças
  (maior-bloco 0 :type fixnum); Tamanho do maior bloco
  (id 0 :type fixnum)
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;                               
;;   FUNCAO ESTADO-OBJECTIVO   ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                              
(defun objectivo? (estado)
 (time-to-stop? tempo-inicio MAX-TEMPO))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;	DEBUG
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun print-tabuleiro (tabuleiro n-lin n-col)
  (let* ((result '())
         (temp-list '()))
    (loop for posy from 0 to (- n-lin 1) do
          (loop for posx from 0 to (- n-col 1) do
                (if (not (eq nil (nth posx (nth posy tabuleiro))))
                (setq temp-list (append temp-list (list (peca-cor (nth posx (nth posy tabuleiro))))))
                 (setq temp-list (append temp-list (list -1))))) ; Caso Não exista peça coloca -1
          (setq result (append result (list temp-list)))
          (setf temp-list '()))
  (print result)))

(defun print-hash (hash)
  (let* ((b-aux (make-bloco)))
 (loop for key being the hash-keys of hash do
       (setf b-aux (gethash key hash))
       (format t "~% Key: ~D Cor Bloco: ~D Numero De Peças: ~D Xmin: ~D Xmax: ~D Ymin: ~D Ymax: ~D Lista Peças: ~A" 
               key (bloco-cor b-aux) (list-length (bloco-lista-pecas b-aux)) 
               (bloco-x-min b-aux) (bloco-x-max b-aux) (bloco-y-min b-aux) 
               (bloco-y-max b-aux) (bloco-lista-pecas b-aux)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;	SUCESSORES
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;--------------------------------------------------------------------------;
; Função que gera sucessores                                               ;
;--------------------------------------------------------------------------;
; ARG1 - estado                                                            ;
;--------------------------------------------------------------------------;
; RET  - Devolve a lista com os estados sucessores                         ;
;--------------------------------------------------------------------------;

(defun gera-sucessores (estado)
  ;(print "entrou: gera-sucessores")
  (let* ((tabuleiro (nos-tabuleiro estado))
         (hash (nos-h-blocos estado))
         (nr-linhas (nos-n-linhas estado))
         (nr-colunas (nos-n-colunas estado))
         (lista()))
    (print "SUCESSORES--------------------------------------------------------------------------------------------")
    ;(print (print-hash hash))
    (loop for key being the hash-keys of hash do     
          (let* ((novo-estado (copia-estado estado))
                 (b-aux (gethash key (nos-h-blocos novo-estado))))
            (if (>= (list-length (bloco-lista-pecas b-aux)) 2)
                (progn
                  (atualiza-tabuleiro (nos-tabuleiro novo-estado) (nos-h-blocos novo-estado))
                  (remove-bloco novo-estado key (nos-h-blocos novo-estado))
                  (let* ((l-margens
                          (gravidade (nos-tabuleiro novo-estado) b-aux (nos-h-blocos novo-estado)))
                         (l-m2 
                          (encosta-esquerda novo-estado (nos-tabuleiro novo-estado) (nos-h-blocos novo-estado) l-margens)))
                    (setf (nos-h-blocos novo-estado) (lista-blocos (nos-tabuleiro novo-estado) 
                                                                  0 (- (nos-n-colunas novo-estado) 1) 
                                                                  0 (- (nos-n-linhas novo-estado) 1)
                                                                  (nos-n-linhas novo-estado) (nos-n-colunas novo-estado) (nos-h-blocos novo-estado))))
                  (maior-bloco novo-estado (nos-h-blocos novo-estado))
                  (if (not (eq (gethash 223 (nos-h-blocos novo-estado)) nil))
                      (progn
                        (print "sucessor")
                        (print (gethash 223 (nos-h-blocos novo-estado)))))
                  (incf *no-id*)
                  (setf (nos-id novo-estado) *no-id*)
                  (incf (nos-prof novo-estado))
                  (push novo-estado lista)
            ))))
    lista))
  


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;	HEURISTICAS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;--------------------------------------------------------------------------;
; Heuristica  que dá mais prioridade a nós com menos blocos                ;
;--------------------------------------------------------------------------;
; ARG1 - estado                                                            ;
;--------------------------------------------------------------------------;
(defun heuristica1 (estado)
  (- 500 (nos-n-pecas estado)))


;Heuristica que adapta a heuristica 1
;para conseguir funcionar com a*
;dá mais importância aos estados que estão a maior profundidade
(defun heuristica2 (estado)
  (let* ((result 0))
  ;(print (- 20000 (+ (* 144 (- 72 (nos-prof estado)))
  ;                   (nos-pontuacao estado))))
  ;(print (print-hash (nos-h-blocos estado)))
    (if (= (nos-prof estado) 0)
        (progn
          (heuristica1 estado))
      (setf result (+ (- 100 (nos-prof estado)) (* 10 (- *max-result* (nos-pontuacao estado))) (heuristica1 estado))))
  (if (< result 1)
      (setf result 1))
    ;(print result)
    result))

(defun heuristica3 (estado)
  (nos-n-pecas estado))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;	PROCURA
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(defun procura-tabuleiro (estado sucessores heuristica)
  ;(print (funcall #'gera-sucessores estado))
  )



(defun procura-alternativa (estado sucessores heuristica))






;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;	FUNÇÔES AUXILIARES
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



(defun atualiza-tabuleiro (tabuleiro ht)
  ;(print "entrou: atualiza-tabuleiro")
  ;(print (print-hash ht))
  (loop for bl being the hash-values of ht do
        (loop for p-pos in (bloco-lista-pecas bl) do
              (setf (nth (car p-pos) (nth (cdr p-pos) tabuleiro)) 
                    (make-peca :pos (cons (car p-pos) (cdr p-pos)) :cor (bloco-cor bl) :bloco (bloco-id bl)))
                ;(print "----------------------------------------------------------------------------")
                ;(print tabuleiro)
              )))
  ;(print "saiu: atualiza-tabuleiro"))

;--------------------------------------------------------------------------;
; Função que cria uma hash table nova a partir de uma existente            ;
;--------------------------------------------------------------------------;
; ARG1 - Hash Table                                                        ;
;--------------------------------------------------------------------------;

(defun copia-hash (hash)
  (let* ((new-hash (make-hash-table))
         (b-aux (make-bloco))
         (l-aux (list))
         (p-aux)
         (novo-bloco))
    (loop for key being the hash-keys of hash do     
          (setf b-aux (gethash key hash))
          (loop for p-pos in (bloco-lista-pecas b-aux) do
                (push (cons (car p-pos) (cdr p-pos)) l-aux))
          (setf novo-bloco (make-bloco :cor (bloco-cor b-aux) 
                                       :lista-pecas l-aux 
                                       :id (bloco-id b-aux) 
                                       :x-min (bloco-x-min b-aux) 
                                       :x-max (bloco-x-max b-aux)
                                       :y-min (bloco-y-min b-aux)
                                       :y-max (bloco-y-max b-aux)))
          (setf (gethash key new-hash) novo-bloco)
          (setf l-aux (list)))    
    new-hash))
  


;--------------------------------------------------------------------------;
; Função que devolve a maior chave da hash table                           ;
;--------------------------------------------------------------------------;
; ARG1 - Hash Table                                                            ;
;--------------------------------------------------------------------------;

(defun ve-maior-hash (ht)
  (let* ((resul -1))
    (loop for k being the hash-keys of ht do
          (when (> k resul) (setq resul k)))
    resul))


;--------------------------------------------------------------------------;
; Função que efectua a cópia de um estado                                  ;
;--------------------------------------------------------------------------;
; ARG1 - estado                                                            ;
;--------------------------------------------------------------------------;


(defun copia-estado (estado)
  ;(print "entrou: copia-estado")
  (make-nos :tabuleiro (cria-tabuleiro-novo (nos-n-linhas estado) (nos-n-colunas estado))
            :h-blocos (copia-hash (nos-h-blocos estado))
            :prof (nos-prof estado)
            :pontuacao (nos-pontuacao estado)
            :n-pecas (nos-n-pecas estado)
            :n-blocos (nos-n-blocos estado)
            :n-linhas (nos-n-linhas estado)
            :n-colunas (nos-n-colunas estado)
            :maior-bloco 0))
                                                                      



;--------------------------------------------------------------------------;
; Função que devolve o tamanho do maior bloco da hash                      ;
;--------------------------------------------------------------------------;
; ARG1 - estado                                                            ;
; ARG2 - hash                                                              ;
;--------------------------------------------------------------------------;

(defun maior-bloco (estado hash)
  ;(print "entrou: maior-bloco")
  (let* ((result 0)
         (tmp 0)
          (b-aux))
          (loop for key being the hash-keys of hash do
                (setf b-aux (gethash key hash))
                (if (< result (list-length (bloco-lista-pecas b-aux)))
                    (setf result (list-length (bloco-lista-pecas b-aux)))))
          (setf (nos-maior-bloco estado) result)   
))

;--------------------------------------------------------------------------;
; Função que remove bloco do tabuleiro e hash table e atualiza a pontuação ;
;--------------------------------------------------------------------------;
; ARG1 - Estado (nó)                                                       ;
; ARG2 - ID do bloco a ser removido                                        ;
; ARG3 - Hash table                                                        ;
;--------------------------------------------------------------------------;

(defun remove-bloco (estado id-bloco ht)
  ;(print "entrou: remove-bloco")
  (if (= id-bloco 223)
      (progn
        (print "entrou: remove-bloco")
        (print (gethash id-bloco ht))))
  (let* ((l-aux (bloco-lista-pecas (gethash id-bloco ht)))
         (pontos (expt (- (list-length l-aux) 2) 2))
         (pos))
    (remhash id-bloco ht)
    (setf (nos-pontuacao estado) (+ (nos-pontuacao estado) pontos))
    (setf (nos-n-pecas estado) (- (nos-n-pecas estado) (list-length l-aux)))
    (loop for pos in l-aux do
          (setf (nth (car pos) (nth (cdr pos) (nos-tabuleiro estado))) NIL))
        (if (> (nos-pontuacao estado) *max-result*)
        (setf *max-result* (nos-pontuacao estado)))))
  ;(print (print-hash ht))
  ;(print "saiu: remove-bloco")))

;--------------------------------------------------------------------------;
; Função que faz cair as peças consoante as leis da gravidade              ;
;--------------------------------------------------------------------------;
; ARG1 - Tabuleiro do jogo                                                 ;
; ARG2 - Bloco que foi removido (fornece as coordenadas)                   ;
; ARG3 - Hash table                                                        ;
;--------------------------------------------------------------------------;
; RET  - Lista com x-min, x-max e y-max dos blocos que removeu             ;  
;--------------------------------------------------------------------------;

(defun gravidade (tabuleiro bloco ht)
  (print "entrou: gravidade")
  (let* ((x-ini (bloco-x-min bloco))
         (x-fin (bloco-x-max bloco))
         (y-ini (bloco-y-max bloco))
         (p-aux)
         (bl-aux)
         (b-aux (make-bloco))
         (contador 0)
         (resul (list x-ini x-fin y-ini)))
    (if (gethash 223 ht)
        (print "entrou: gravidade1"))
    (loop for coluna from 0 to (- (list-length (first tabuleiro)) 1) do                      ; Para evitar ver peças desnecessárias no lista-blocos
          (loop for linha from (- (list-length tabuleiro) 1) downto 0 do                     ; --Y min não interessa porque as peças caem
                (setq p-aux (nth coluna (nth linha tabuleiro)))
                (if (not (eq p-aux NIL))                                                     ; Se houver peça na posição indicada
                    (if (> contador 0)                                                       ; Se houver espaços vazios abaixo da peça
                        (progn                                                               ; --
                          (setf bl-aux (peca-bloco p-aux))                                   ; -- Vê o bloco da peça que vai ser deslocada para baixo
                          (if (not (= bl-aux -1))                                            ; -- Se existir (vai tratar do bloco) 
                              (progn                                                         ; ----
                                (setf b-aux (gethash bl-aux ht))                             ; ---- Guarda o bloco para ser acedido facilmente
                                (if (< (bloco-x-min b-aux) (first resul))                    ; ---- 
                                    (if (<= (bloco-x-min b-aux) 0)                           ; ------
                                        (setf (first resul) 0)                               ; ------
                                      (setf (first resul) (- (bloco-x-min b-aux) 1))))       ; ------
                                (if (> (bloco-x-max b-aux) (second resul))                   ; ----
                                    (setf (second resul) (bloco-x-max b-aux)))               ; ------
                                (if (> (bloco-y-max b-aux) (third resul))                    ; ----
                                    (setf (third resul) (bloco-y-max b-aux)))                ; ------
                                (loop for p-pos in (bloco-lista-pecas b-aux) do              ; ---- Para cada peça do bloco a ser removido
                                      (setf (peca-bloco (nth (car p-pos) (nth (cdr p-pos) tabuleiro))) -1))   ; Remove o bloco das peças
                                (if (= bl-aux 223)
                                    (progn
                                      (print "gravidade")
                                      (print (gethash bl-aux ht))))
                                (remhash bl-aux ht)))                                                ; --Remove o bloco da hash
                          (setf (cdr (peca-pos p-aux)) (+ (cdr (peca-pos p-aux)) contador))  ; Puxa a peça para baixo
                          (setf (nth coluna (nth linha tabuleiro)) NIL)                      ; Atualiza o tabuleiro
                          (setf (nth coluna (nth (+ linha contador) tabuleiro)) p-aux)))     ; Atualiza o tabuleiro
                  (incf contador)))                                                          ; Se for uma posição vazia, incrementa o contador
          (setq contador 0))                                                                 ; Reset do contador a cada coluna nova
    resul))                                                               


;---------------------------------------------------------------------------;
; Função que encosta as peças à esquerda, eliminando colunas vazias no meio ;
;---------------------------------------------------------------------------;
; ARG1 - estado
; ARG2 - Tabuleiro do jogo                                                  ;
; ARG3 - Hash table                                                         ;
;---------------------------------------------------------------------------;
; RET  - Nº de shifts que efetuou                                           ;
;---------------------------------------------------------------------------;


(defun encosta-esquerda (estado tabuleiro ht l-margens)
  (print "entrou: encosta-esquerda")
  ;(print (print-hash ht))
  (let* ((x-fin (- (list-length (first tabuleiro)) 1))
         (y-ini (- (list-length tabuleiro) 1))
         (p-aux)
         (resul (list (first l-margens) (second l-margens) (third l-margens)))
         (contador 0))
    (loop for coluna from 0 to x-fin do
          (if (eq (nth coluna (nth y-ini tabuleiro)) NIL)
              (incf contador)                                                                         ; Se for uma posição vazia, incrementa o contador
            (if (> contador 0)
                (loop for linha from y-ini downto 0 do
                      (setq p-aux (nth coluna (nth linha tabuleiro)))
                      (if (not (eq p-aux NIL))                                                        ; Se houver peça na posição indicada
                          (progn
                            (setf (car (peca-pos p-aux)) (- (car (peca-pos p-aux)) contador))         ; Puxa a peça para a esquerda
                            (setf (nth coluna (nth linha tabuleiro)) NIL)                             ; Atualiza o tabuleiro
                            (setf (nth (- coluna contador) (nth linha tabuleiro)) p-aux)              ; Atualiza o tabuleiro
                            (if (not (= (peca-bloco p-aux) -1))
                                (progn
                                  (let* ((b-aux (gethash (peca-bloco p-aux) ht))
                                         (l-aux (list)))
                                    (loop for p in (bloco-lista-pecas b-aux) do
                                          (if (and (= coluna (car p)) (= linha (cdr p)))
                                              (push (cons (- coluna contador) linha) l-aux)
                                            (push p l-aux)))
                                    (setf (bloco-lista-pecas (gethash (peca-bloco p-aux) ht)) l-aux)
                                    (setq l-aux (list))
                                    (if (< (- coluna contador) (bloco-x-min b-aux))
                                        (progn
                                          (setf (bloco-x-min (gethash (peca-bloco p-aux) ht)) (- coluna contador))
                                          (if (< (- coluna (+ contador 1)) (first l-margens))
                                              (if (< (- coluna (+ contador 1)) 0)
                                                  (setf (first resul) 0)
                                                (setf (first resul) (- coluna (+ contador 1)))))))                                  
                                    (if (>= coluna (bloco-x-max b-aux))
                                        (setf (bloco-x-max (gethash (peca-bloco p-aux) ht)) (- coluna contador)))))))                       
                        (return))))))                                                                 ; Quando vê NIL, salta para a próxima coluna
    (setf (nos-n-colunas estado) (- (nos-n-colunas estado) contador))
    ;(print tabuleiro)
    ;(print contador)
    ;(print (print-hash ht))
    ;(print "saiu: encosta-esquerda")
    resul))      



;----------------------------------------;
; Função que junta 2 blocos da mesma cor ;
; Mantém o 1º bloco que é passado        ;
; ---------------------------------------;
; ARG1 - tabuleiro com as peças          ;
; ARG2 - hashtable dos blocos            ;
; ARG3 - chave do bloco a manter         ;
; ARG4 - chave do bloco que desaparece   ;
;----------------------------------------;

(defun junta-blocos (tabuleiro ht chave-b1 chave-b2)
  (print "entrei: junta-blocos")
  (if (or (= chave-b1 223) (= chave-b2 223))
      (progn
        (print "b1")
        (print (gethash chave-b1 ht))
        (print "b2")
        (print (gethash chave-b2 ht))))
  (let* ((b-aux (gethash chave-b1 ht))                                   ; Referência para o bloco que se vai manter
         (b-trash (gethash chave-b2 ht))                                 ; Referência para o bloco que vai à vida
         (l-aux (bloco-lista-pecas b-aux))                               ; Lista das peças do bloco que se vai manter
         (xmin (bloco-x-min b-trash))                                    ; X Mínimo do bloco que vai à vida
         (xmax (bloco-x-max b-trash))                                    ; X Máximo do bloco que vai à vida
         (ymin (bloco-y-min b-trash))                                    ; Y Mínimo do bloco que vai à vida
         (ymax (bloco-y-max b-trash)))                                   ; Y Máximo do bloco que vai à vida
  (loop for p-pos in (bloco-lista-pecas b-trash) do
        (setf (peca-bloco (nth (car p-pos) (nth (cdr p-pos) tabuleiro)))
              chave-b1)                                                  ; Muda o bloco da peça
        (push (cons (car p-pos) (cdr p-pos)) l-aux))                     ; Insere a peça na lista do bloco original       
  (setf (bloco-lista-pecas b-aux) l-aux)                                 ; Coloca a nova lista no bloco original
  (if (> (bloco-x-min b-aux) xmin)                                       ;;---------------------------------------------;
      (setf (bloco-x-min b-aux) xmin))                                   ;;                                             ;
  (if (< (bloco-x-max b-aux) xmax)                                       ;;                                             ;
      (setf (bloco-x-max b-aux) xmax))                                   ;; Atualiza os mínimos e máximos do bloco      ;
  (if (> (bloco-y-min b-aux) ymin)                                       ;;                                             ;
      (setf (bloco-y-min b-aux) ymin))                                   ;;                                             ;
  (if (< (bloco-y-max b-aux) ymax)                                       ;;                                             ;
      (setf (bloco-y-max b-aux) ymax))                                   ;;---------------------------------------------;
  (setf (gethash chave-b1 ht) b-aux)                                     ; Atualiza o bloco original na HT
  (if (or (= chave-b1 223) (= chave-b2 223))
      (progn
        (print "b1-exit")
        (print (gethash chave-b1 ht))
        (print "b2-exit")
        (print (gethash chave-b2 ht))
        (print (print-hash ht))
        (print-tabuleiro tabuleiro 15 10)))
  (remhash chave-b2 ht)                                                  ; Remove o 2º bloco da HT
  ;(print "sai: junta-blocos")
))                                                


;---------------------------------------------;
; Função que percorre uma determinada zona    ;
; e determina os diferentes blocos existentes ;
; --------------------------------------------;
; ARG1 - tabuleiro com as peças               ;
; ARG2 - limite esquerda                      ;
; ARG3 - limite direita                       ;
; ARG4 - limite cima                          ;
; ARG5 - limite baixo                         ;
; ARG6 - numero linhas do tabuleiro           ;
; ARG7 - numero colunas do tabuleiro          ;
; ARG8 - hash com bloocs                      ;
;---------------------------------------------;

(defun lista-blocos (tabuleiro x-ini x-fin y-ini y-fin n-lin n-col ht)
  ;(print "entrei: lista-blocos")
  ;(print (print-hash hash))
  (let* ((p-aux)
         (b-aux)
         (contador (+ (ve-maior-hash ht) 1)))
    (loop for posy from y-ini to y-fin do
          (loop for posx from x-ini to x-fin do
                (if (not (eq (nth posx (nth posy tabuleiro)) nil))
                    (progn      
                      (setq p-aux (nth posx (nth posy tabuleiro)))
                      (if (= (peca-bloco p-aux) -1)                                          ; Vê se a peça já está num bloco                          
                          (progn                                                             ; Se não estiver num bloco
                            (setf (peca-bloco p-aux) contador)                               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            (setq b-aux (make-bloco :cor (peca-cor p-aux)                    ;;
                                                    :lista-pecas (list (cons posx posy))     ;;
                                                    :id contador                             ;;
                                                    :x-min posx                              ;;
                                                    :x-max posx                              ;;
                                                    :y-min posy                              ;;
                                                    :y-max posy))                            ;; Cria um bloco para a peça
                            (setf (gethash (peca-bloco p-aux) ht) b-aux)                  ;; coloca-a no bloco
                            (setf (nth posx (nth posy tabuleiro)) p-aux)                     ;; e guarda o bloco para referência
                            (incf contador))
                        (setf b-aux (gethash (peca-bloco p-aux) ht)))
                      (if (and (not (>= posx (- n-col 1)))                                   ; Estou na última coluna do tabuleiro?
                               (not (eq (nth (+ posx 1) (nth posy tabuleiro)) nil)))         ; A peça à frente existe?
                          (ve-frente tabuleiro p-aux b-aux posx posy ht))                 ; --Se não, verifica bloco à direita
                      (if (not (>= posy (- n-lin 1)))                                        ; Estou na última linha do tabuleiro?                                       
                          (ve-abaixo tabuleiro p-aux b-aux posx posy ht))))))
    ;(print (print-hash hash))
    ;(print "sai: lista-blocos")
    ht))
 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;	FUNÇÔES DE LEITURA DE TABULEIRO INICIAL
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;        


;--------------------------------------------------------------------;
; Função que gera peças e constrói um tabuleiro novo                 ;
; -------------------------------------------------------------------;
; ARG1 - numero de linhas                                            ;
; ARG2 - numero de colunas                                           ;
;--------------------------------------------------------------------;

(defun cria-tabuleiro-novo (n-lin n-col)
  (let* ((resul (list))
         (posx 0)
         (posy 0)
         (l-aux (list)))
   ;(print "entrou: cria-tabuleiro-novo")
    (loop for linha from 0 to (- n-lin 1) do
          (loop for coluna from 0 to (- n-col 1) do
                (setq l-aux (append l-aux (list NIL))))
          (setq resul (append resul (list l-aux)))
          (setq l-aux (list)))
    resul))


;--------------------------------------------------------------------;
; Função que gera peças e constrói um tabuleiro a partir do original ;
; -------------------------------------------------------------------;
; ARG1 - tabuleiro com lista de cores recebido no input              ;
; ARG2 - numero de colunas                                           ;
;--------------------------------------------------------------------;

(defun cria-tabuleiro (tabuleiro n-col)
  (let* ((resul (list))
         (posx 0)
         (posy 0)
         (p-aux)
         (l-aux (list)))
    ;(print "entrou: cria-tabuleiro")
    (loop for linha in tabuleiro do
          (loop for coluna in linha do
                (if (= coluna -1)
                    (setq p-aux nil)
                  (setq p-aux (make-peca :pos (cons posx posy) :cor coluna :bloco -1)))
                (setq l-aux (append l-aux (list p-aux)))
                (if (not (= posx (- n-col 1)))                                       ; Avança no Y caso não esteja no final da linha
                    (incf posx)               
                  (progn                                                             ; Se estiver no Final, desce 1 linha e faz reset no posx
                    (setq resul (append resul (list l-aux)))
                    (setq l-aux (list))
                    (setf posx 0)          
                    (incf posy)))))
                resul))
                      


;----------------------------------------------------------------------;
; Função que verifica se a peça à direita pertence ao mesmo bloco      ;
; ---------------------------------------------------------------------;
; ARG1 - tabuleiro com as peças                                        ;
; ARG2 - peça a partir da qual se verifica se é pertence ao mesmo bloco;
; ARG3 - bloco a adicionar caso seja da mesma cor                      ;
; ARG4 - coord.x da posicao da peça p-aux                              ;
; ARG5 - coord.y da posicao da peça p-aux                              ;
; ARG6 - hash com blocos                                               ;
;----------------------------------------------------------------------;

(defun ve-frente (tabuleiro p-aux b-aux posx posy ht)
  ;(print "entrou: ve-frente")
  (let* ((l-aux (bloco-lista-pecas b-aux))
         (p-dir (nth (+ posx 1) (nth posy tabuleiro)))
         (chave-b1 (peca-bloco p-aux))
         (chave-b2 (peca-bloco p-dir)))
    (if (= (peca-bloco p-aux) 223)
        (progn
          (print "ve-frente")
          (print p-aux)
          (print p-dir)
          (print b-aux)
          (print (gethash (peca-bloco p-aux) ht))
          (print chave-b1)
          (print chave-b2)
          (print "ve-frente-2")))
    (if (= (peca-cor p-aux) (peca-cor p-dir))                                         ; Se o da frente for igual
        (if (= -1 chave-b2)
            (progn
              ;(format t "Right Match On: posx: ~D posy: ~D ~% " posx posy)
              (setf (peca-bloco p-dir) (peca-bloco p-aux))                            ; Junta a informação do bloco à peça da direita
              (setf (nth (+ posx 1) (nth posy tabuleiro)) p-dir)                      ; Coloca a peça atualizada no tabuleiro
              (push (cons (+ posx 1) posy) l-aux )                                    ; Adiciona a peça à lista para atualizar o bloco
              (setf (bloco-lista-pecas (gethash chave-b1 ht)) l-aux)                  ; Atualiza o bloco na hash
              (if (> (+ posx 1) (bloco-x-max (gethash chave-b1 ht)))                  ; Se a peça adicionada tiver x maior que o máximo do bloco
                  (setf (bloco-x-max (gethash chave-b1 ht)) (+ posx 1))))             ; --Incrementa o xmax do bloco     
          (if (not (= chave-b1 chave-b2))
              (if (>= (list-length (bloco-lista-pecas (gethash chave-b1 ht))) 
                      (list-length (bloco-lista-pecas (gethash chave-b2 ht))))
                  (junta-blocos tabuleiro ht chave-b1 chave-b2)
                (junta-blocos tabuleiro ht chave-b2 chave-b1)))))
    (if (= (peca-bloco p-aux) 223)
        (progn
          (print "sai: ve-frente")
          (print p-aux)
          (print chave-b1)
          (print chave-b2)
          (print (gethash chave-b1 ht))
          (print (gethash chave-b2 ht))
          (print (print-hash ht))
          (print "sai: ve-frente2")))
    ;(print (print-hash ht))
    ;(print "saiu: ve-frente")
))


;----------------------------------------------------------------------;
; Função que verifica se a peça abaixo pertence ao mesmo bloco         ;
; ---------------------------------------------------------------------;
; ARG1 - tabuleiro com as peças                                        ;
; ARG2 - peça a partir da qual se verifica se é pertence ao mesmo bloco;
; ARG3 - bloco a adicionar caso seja da mesma cor                      ;
; ARG4 - coord.x da posicao da peça p-aux                              ;
; ARG5 - coord.y da posicao da peça p-aux                              ;
; ARG6 - hash com blocos                                               ;
;----------------------------------------------------------------------;

(defun ve-abaixo (tabuleiro p-aux b-aux posx posy ht)
  (print "entrou: ve-abaixo")
  ;(print (print-hash ht))
  
  (let* ((p-baixo (nth posx (nth (+ posy 1) tabuleiro)))
         (chave-b1 (peca-bloco p-aux))
         (l-aux (bloco-lista-pecas (gethash chave-b1 ht)))
         (chave-b2 (peca-bloco p-baixo)))
    (if (= (peca-bloco p-aux) 223)
        (progn
          (print "ve-abaixo")
          (print p-aux)
          (print p-baixo)
          (print (gethash (peca-bloco p-aux) ht))
          (print "ve-abaixo-exit")))
    (if (= (peca-cor p-aux) (peca-cor p-baixo))                                             ; Se o da frente for igual
        (if (= -1 chave-b2)
                (progn
                  (if (= (peca-bloco p-aux) 223)
                       (progn
                         (print b-aux)
                         (print l-aux)
                         (print (gethash 223 ht))
                         (print "ve-abaixo-meio")))
                  ;(format t "Down Match On: posx: ~D posy: ~D ~% " posx posy)              
                  (setf (peca-bloco p-baixo) (peca-bloco p-aux))                            ; Junta a informação do bloco à peça da direita
                  (setf (nth posx (nth (+ posy 1) tabuleiro)) p-baixo)                      ; Coloca a peça atualizada no tabuleiro
                  (push (cons posx (+ posy 1)) l-aux)                                       ; Adiciona a peça à lista para atualizar o bloco
                  (setf (bloco-lista-pecas (gethash chave-b1 ht)) l-aux)                    ; Atualiza o bloco na hash
                  (if (> (+ posy 1) (bloco-y-max (gethash chave-b1 ht)))                    ; Se a peça adicionada tiver y maior que o máximo do bloco
                      (setf (bloco-y-max (gethash chave-b1 ht)) (+ posy 1))))               ; --Incrementa o ymax do bloco 
          (if (not (= chave-b1 chave-b2))
              (progn
                (if (= chave-b1 223)
                    (progn
                      (print (print-hash ht))
                      (print p-aux)
                      (print "ve-abaixo-2")))
                ;(print chave-b1)
                ;(print (gethash chave-b1 ht))
                (if (>= (list-length (bloco-lista-pecas (gethash chave-b1 ht))) 
                      (list-length (bloco-lista-pecas (gethash chave-b2 ht))))
                    (progn
                      (print "ve-abaixo-JB1")
                      (junta-blocos tabuleiro ht chave-b1 chave-b2))
                  (progn
                    (print "ve-abaixo-JB2")
                    (junta-blocos tabuleiro ht chave-b2 chave-b1)))))))
    (print (gethash 223 ht))
    (print "saiu: ve-abaixo")
))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;	FUNÇÂO PRINCIPAL
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 

(defun resolve-same-game (problema algoritmo)
  (let* ((tab (cria-tabuleiro problema (list-length (first problema))))
         (h-blocos (lista-blocos tab 0 (- (list-length (first problema)) 1) 0 (- (list-length problema) 1) (list-length problema) (list-length (first problema)) (make-hash-table)))
         (estado-inicial (make-nos :n-pecas (* (list-length problema) (list-length (first problema))) :n-blocos (hash-table-count h-blocos) :tabuleiro tab :h-blocos h-blocos :n-linhas (list-length problema) :n-colunas (list-length (first problema)) :maior-bloco 0))
         ;(b-aux (gethash 0 h-blocos))
        ; (g-sucessores	#'gera-sucessores)
        ; (heuristica1		#'heur-melhor-primeiro)
        ; (heuristica2		#'heur-melhor-primeiro-posicao-menor)
        ; (heuristica-opt	#'heur-menor-altura)
         resul solucao)
    (setf *tamanho-tabuleiro* (* (list-length (nos-tabuleiro estado-inicial)) (list-length (first (nos-tabuleiro estado-inicial)))))
    (print *tamanho-tabuleiro*)

    ;(print (print-hash h-blocos))
    (setf tempo-inicio (get-internal-run-time))
    (setf resul
          (cond ((string-equal algoritmo "melhor.abordagem")
                 (procura-tabuleiro estado-inicial (list #'gera-sucessores) heuristica1))

                ((string-equal algoritmo "a*.melhor.heuristica")
                 (setf solucao (procura (cria-problema estado-inicial (list #'gera-sucessores) :objectivo? #'objectivo? :custo (always 0) :heuristica #'heuristica2) "a*" :espaco-em-arvore? T)))

                ((string-equal algoritmo "a*.melhor.heuristica.alternativa")
                 (procura-tabuleiro estado-inicial g-sucessores heuristica2))

                ((string-equal algoritmo "sondagem.iterativa")
                 (sondagem-iterativa estado-inicial))

                ((string-equal algoritmo "abordagem.alternativa")
                 (setf solucao (time (procura (cria-problema estado-inicial (list #'gera-sucessores) :objectivo? #'objectivo? :estado= #'equal) 
									"profundidade" :espaco-em-arvore? T))))                 ))
    (print "FIM")
    (print *max-result*)
    (setf *max-result* 0)
    (setf *no-id* 0)
    (setf tamanho-tabuleiro 0)
    ;(setf solucao (converte-solucao solucao))

  
    solucao))

;(print (resolve-same-game '((2 1 3 2 3 3 2 3 3 3) (1 3 2 2 1 3 3 2 2 2) (1 3 1 3 2 2 2 1 2 1) (1 3 3 3 1 3 1 1 1 3)) "abordagem.alternativa"))

;(print (resolve-same-game '((4 3 3 1 2 5 1 2 1 5) (2 4 4 4 1 5 2 4 1 2) (5 2 4 1 4 5 1 2 5 4) (1 3 1 4 2 5 2 5 4 5)) "a*.melhor.heuristica"))

(print (resolve-same-game '((3 3 3 2 1 2 3 1 3 1) (1 1 2 3 3 1 1 1 3 1) (3 3 1 2 1 1 3 2 1 1) (3 3 2 3 3 1 3 3 2 2) (3 2 2 2 3 3 2 1 2 2) (3 1 2 2 2 2 1 2 1 3) (2 3 2 1 2 1 1 2 2 1) (2 2 3 1 1 1 3 2 1 3) (1 3 3 1 1 2 3 1 3 1) (2 1 2 2 1 3 1 1 2 3) (2 1 1 3 3 3 1 2 3 1) (1 2 1 1 3 2 2 1 2 2) (2 1 3 2 1 2 1 3 2 3) (1 2 1 3 1 2 2 3 2 3) (3 3 1 2 3 1 1 2 3 1)) "abordagem.alternativa"))
